# Ticket Maps

[![Build Status](https://travis-ci.com/anthonywilliams/ticketmap.svg?branch=main)](https://travis-ci.com/anthonywilliams/ticketmap)

It has been an increasingly common scenario that I've encountered
where you have some ID that's monotonically increasing, such as a
subscription or connection index, or user ID, and you need your C++
program to hold some data that's associated with that ID value. The
program can then pass around the ID, and use that ID to access the
associated data at a later point.

Over time, IDs can become invalidated, so the data associated with
that value is removed, and you end up with a sparse set of
currently-active IDs. You would, therefore, naturally lean towards using
a map (whether a [std::map](https://en.cppreference.com/w/cpp/container/map),
[std::unordered_map](https://en.cppreference.com/w/cpp/container/unordered_map)
or some other custom map) to associate the data with the ID.

Often such maps are implemented as node-based containers, which means
that the nodes can be allocated at disparate memory addresses, which
is bad for cache performance. Adding and removing nodes also always
requires memory allocation/deallocation.

In his ["Better Code:
Relationships"](https://sean-parent.stlab.cc/papers-and-presentations/#better-code-relationships)
presentation, Sean Parent describes an alternative implementation,
which he calls the "Russian Coat-Check Algorithm". In this algorithm,
the map is implemented as a vector of pairs of key/optional
data. Because the keys come from a monotonically increasing index, the
vector is *always sorted*, and inserts are always at the end. Entries
can be removed by clearing the data, and if there are too many empty
entries then the vector can be compacted. Lookups are always fast,
because the vector is always sorted, so a simple binary search will
find the right element.

This library is an implementation of that algorithm, which I call a
*Ticket Map*: it maps a *Ticket* to a *Value*. When you insert a
value, it is assigned the next available ticket value. You can later
access or erase the value using that ticket.

~~~cpp
#include <string>
#include <iostream>
#include "ticket_map.hpp"

int main() {
    jss::ticket_map<int, std::string> map;

    auto ticket1 = map.insert("hello");
    auto ticket2 = map.insert("world");
    
    std::cout << map[ticket1] << " " << map[ticket2] << std::endl;
    
    map.erase(ticket1);
}
~~~

## License

This code is released under the [Boost Software License](https://www.boost.org/LICENSE_1_0.txt):

> Boost Software License - Version 1.0 - August 17th, 2003
>
> Permission is hereby granted, free of charge, to any person or organization
> obtaining a copy of the software and accompanying documentation covered by
> this license (the "Software") to use, reproduce, display, distribute,
> execute, and transmit the Software, and to prepare derivative works of the
> Software, and to permit third-parties to whom the Software is furnished to
> do so, all subject to the following:
>
> The copyright notices in the Software and this entire statement, including
> the above license grant, this restriction and the following disclaimer,
> must be included in all copies of the Software, in whole or in part, and
> all derivative works of the Software, unless such copies or derivative
> works are solely in the form of machine-executable object code generated by
> a source language processor.
>
> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
> IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
> FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
> SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
> FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
> ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
> DEALINGS IN THE SOFTWARE.
